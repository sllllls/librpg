##########
# map.py #
##########

A map is a place that a Party can explore. This package uses Map, MapModel and MapView as a Model-View-Controller architecture for managing gameplay.

==================
MapModel (virtual)
==================

The MapModel is the class that models a map's data and behaviour. It is the Model component of the MVC pattern. MapModel is a class made to be inherited, so that specific behavior (objects, areas, parallel processes) may be added.

-----
Usage
-----

To use a map, three things must be done:
1. Create a .map file with the layout of that map. Pass this file's name to the MapModel constructor.
2. Define the tileset that will be used for drawing the map's terrain and scenario layers. Pass the image and boundaries files' names to the MapModel constructor.
3. Write a class that inherits from MapModel (for example MyMapModel), overriding only the initialize() method with a routine that places the objects and area of the map to an initial state.
When this is done, instantiate the derived class (MyMapModel), call add_party() to place the active party there, instantiate a Map passing MyMapModel as map_model, and finally call the Map object's gameloop() method.

To add and remove objects from the map, use add_object() and remove_object(). To add and remove areas, use add_area() and remove_area().

----------
Attributes
----------

party: Party (read-only)
Active Party on this Map.

party_avatar: PartyAvatar (read-only)
MapObject representation of the active Party.

party_movement: Direction (private)
Direction to which the party is currently moving.

width: int (read-only)
Map width in tiles.

height: int (read-only)
Map height in tiles.

map_file: string (read-only)
Name of the file that contains the map layout.

terrain_tileset_files: (string, string) (read-only)
Pair of names of the files that contain the terrain tileset image and boundaries.

scenario_tileset_files: (string, string) (read-only)
Pair of names of the files that contain the scenario tileset image and boundaries.

terrain_tileset: TileSet (read-only)
Tileset to draw terrain layer.

scenario_tileset: Tileset (read-only)
Tileset to draw scenario layer.

terrain_layer: Matrix<Tile> (read-only)
Matrix with the tiles that compose the terrain layer.

scenario_layer: Matrix<int> (read-only)
Matrix with the ids of the tiles that compose the scenario layer.

object_layer: Matrix<ObjectCell> (read-only)
Matrix with the objects that each tile contains.

area_layer: Matrix<MapArea> (read-only)
Matrix with the area to which each tile belongs.

areas: [MapArea] (read-only)
All areas in the map.

objects: [MapObject] (read-only)
All objects in the map.

local_state: object (read-only)
Local state to store persistent data about that map. It may be read after the gameloop() is broken.

-------
Methods
-------

__init__(map_file: string, map_file: string, terrain_tileset_files: (string, string), scenario_tileset_files: (string, string))
Creates a map loaded from the specified files.

initialize(local_state: object) (virtual)
Puts the map in an initial, virgin state if the local_state specified is None. Puts the map in a state loaded from the local_state, otherwise.

save() (virtual)
Saves the map's state to map.local_state.

load_from_map_file() (internal)
Loads data from 'map_file'.

add_party(party: Party, position: Position, facing = Direction.DOWN: Direction, speed = MapObject.NORMAL_SPEED: int)
Adds a party to the Map at the given position.

remove_party() -> (Party, Position)
Removes the party from the Map, returning it and its position. Returns (None, None) if there is no party in the map.

add_object(object: MapObject, position: Position) -> boolean
Adds an object to the map at the specified position. Returns whether the operation was successful (it can fail when the position is occupied by an obstacle and the object to be added is also an obstacle).

remove_object(object: MapObject) -> Position
Removes an object from the map and returns the Position where it was. Returns None if the object was not in the map.

move_object(object: MapObject, old_pos: Position, new_pos: Position)
Moves an object inside the map.

add_area(area: MapArea)
Adds an area to the map. Any tiles in that area that were already allocated to another will be changed to belong only to the new area.

remove_area(area: MapArea) -> boolean
Removes an area from the map, setting the tiles that were allocated to it to a free state.

try_to_move(object: MapObject, direction: int) -> boolean
Tries to move an object to the specified direction (Direction.UP, Direction.DOWN, Direction.LEFT or Direction.RIGHT, imported from librpg.util). Return whether the object could be moved.

try_to_move_party(direction: int) -> boolean
Tries to move the party to the specified direction (Direction.UP, Direction.DOWN, Direction.LEFT or Direction.RIGHT, imported from librpg.util). Return whether the party could be moved.


===
Map
===

The Map class controls all events occuring in the MapModel, including moving the party according to the player input. The Map is the Controller component of the MVC architecture.

-----
Usage
-----

The Map class has to be used along with the MapModel passed as parameter to its constructor. When gameloop() is called, the map will start to actually run.

----------
Attributes
----------

map_view: MapView (read-only)
Handle to the MapView associated to that map, which will display the map on the screen.

map_model: MapModel (read-only)
Handle to the MapModel for that map.

must_exit: bool (public)
Flag to break the map's gameloop. When any object sets it, the Map will be destroyed after the current iteration.

-------
Methods
-------

__init__(map_model: MapModel, local_state = None: object)
Creates a map controller to 'map_model', loaded from 'local_state'.

gameloop()
Processes events and moves the party around.

process_input() -> bool
Processes the user input, reacting to the commands.
